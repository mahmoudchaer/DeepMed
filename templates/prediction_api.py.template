import os
import pandas as pd
import numpy as np
import joblib
from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/app/uploads'
app.config['RESULTS_FOLDER'] = '/app/results'
MODEL_PATH = os.environ.get('MODEL_PATH', '/app/model_files/model.joblib')

# Create necessary directories
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['RESULTS_FOLDER'], exist_ok=True)

# Load the model at startup
logger.info(f"Loading model from {MODEL_PATH}")
model_info = joblib.load(MODEL_PATH)
model = model_info['model']
logger.info(f"Model loaded: {type(model).__name__}")

# Get label encoder if it exists
label_encoder = model_info.get('label_encoder', None)

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'ok', 'model_type': type(model).__name__})

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    
    try:
        # Save the uploaded file
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        
        # Load data
        data = pd.read_csv(filepath)
        logger.info(f"Loaded data with {data.shape[0]} rows and {data.shape[1]} columns")
        
        # Make predictions
        predictions = model.predict(data)
        
        # Process predictions
        if label_encoder is not None:
            # Create a mapping dictionary from encoded to decoded values
            mapping = dict(zip(range(len(label_encoder.classes_)), label_encoder.classes_))
            # Map predictions to their decoded values
            decoded_predictions = [mapping[pred] for pred in predictions]
            results_df = pd.DataFrame({'Prediction': decoded_predictions})
        else:
            results_df = pd.DataFrame({'Prediction': predictions})
        
        # Calculate distribution for classification problems
        if predictions.dtype == 'int64' or predictions.dtype == 'int32' or (label_encoder is not None):
            value_counts = results_df['Prediction'].value_counts()
            distribution = []
            for val, count in value_counts.items():
                percentage = (count / len(predictions) * 100).round(2)
                distribution.append({
                    'class': str(val),
                    'count': int(count),
                    'percentage': float(percentage)
                })
        else:
            distribution = None
        
        # Save results
        results_path = os.path.join(app.config['RESULTS_FOLDER'], f"predictions_{filename}")
        results_df.to_csv(results_path, index=False)
        
        return jsonify({
            'success': True,
            'predictions_file': results_path,
            'row_count': len(predictions),
            'distribution': distribution
        })
        
    except Exception as e:
        logger.error(f"Prediction error: {str(e)}", exc_info=True)
        return jsonify({'error': str(e)}), 500

@app.route('/download/<filename>')
def download_file(filename):
    filepath = os.path.join(app.config['RESULTS_FOLDER'], filename)
    if not os.path.exists(filepath):
        return jsonify({'error': 'File not found'}), 404
    
    # Read the file and return its contents
    with open(filepath, 'r') as f:
        content = f.read()
    
    return content

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port) 